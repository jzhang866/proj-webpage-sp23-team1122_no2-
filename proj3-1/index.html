<style>

	*{
		font-family: "Times New Roman";
	}

	h1{
		font-size: 70px;
	}

	h2{
		font-size: 40px;
	}

	p{
		font-size: 20px;
	}

	ul{
		font-size: 30px;
	}

	body {
		color: black;
	}

	.task_img {
		width: 800px;
		margin: 20px;
	}

	.task3 {
		height: 500px;
		width:  500px;
		margin: 20px;
	}

</style>

<html>
<head>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body style="padding: 20PX;">
<div class="container text-center">
	<h1 id = "project-1-rasterizer">Project 3: PathTracer</h1>
	<p>Partners: Jinghua Zhang, Zhiwei Zheng</p>
	<p>Here is the link to our pages: <a href="https://jzhang866.github.io/proj-webpage-sp23-team1122_no2-/">https://jzhang866.github.io/proj-webpage-sp23-team1122_no2-/</a></p>
</div>
<br>

<div class="container">
	<h2 id="overview">Overview</h2>
	<p>
		In assignment 2, we have implemented some basic tools for bezier curves and extended the de Casteljau's algorithm to a three dimension space. We have also learnt the half edge data structure and basic tools to flip and split
		edges, which were then used in loop subdivision for mesh unsampling.
	</p>
</div>

<div class="container">
	<h2 id="task1">Part 1</h2>
	<p>
		1.1 About the ray generation, we cast one ray per pixel. In some other words, we generate a ray starting at the camera and going through the
		corresponding pixel to obtain the information(shape and appearance) in environments. In practice, we might generate several rays per pixel and average the results as the value
		of the pixel. About the primitive intersection, we would test whether the generated rays hit or intersect any objects in environments after generating rays. We would obtain the value
		by testing whether the ray hit any objects and what's the first object that the ray hits. We test the intersection by solving equations and usually the information of the first hit object would be the
		value of the ray.
		<br>
		1.2 In our implementation, we test triangle intersection by first testing whether the ray intersects with the plane which the triangle is in. This can be easily achieved since we
		have the vertices of the triangle, which allow us to get the norm of the plane. Since we can also get the ray equation with respect to t and the plane equation with respect to t. Then we can
		test whether there is a point with some specific t' satisfies both equations and examine the validity of t'. Then we would test whether the point is in the triangle as what we did in
		assignment 1. If it is, we would return true and update the range of ray's t. Otherwise, we would simply return false.
		<br>
		1.3
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t1CBempty.png" ><p>CBempty</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t1CBgems.png" ><p>CBgems</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t1CBspheres.png" ><p>CBspheres</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t1cow.png" ><p>cow</p></div>
	</div>
	</p>


</div>

<div class="container">
	<h2 id="task2">Part 2</h2>
	<p>
		2.1 To construct BVH, we first implement some base case. Specifically, we first check whether the number of input primitives is less than the max_leaf_size. If true, we would take this node as a
		leaf and return. If not, we would split these primitives into two parts through a heuristic method, and then we would recursively call construct_bvh to create the two corresponding nodes and assign
		these two nodes as the left and the right child node of the previous one. About our heuristic method used to separate primitives into two groups, we first obtain the mean of the centroids of the bounding boxes of all
		primitives. Then we would count the numbers of primitives in two groups after the separation. Specifically, the primitives whose x is smaller than the mean's would be taken in one group and others would
		be in the other group. We do these along x-axis, y-axis and z-axis correspondingly. Then, we would choose the axis, along which the numbers of primitives assigned into two groups are as close as possible, as the final axis used
		to split primitives. We think this would help us to split primitives as evenly as possible, trying to avoid creating some empty nodes.


		<br>
		2.2
		<div class="row justify-content-md-center text-center">
			<div class="col-md-6"><img class="img-fluid" src="img/t21blob.png" ><p>blo</p></div>
			<div class="col-md-6"><img class="img-fluid" src="img/t21CBdragon.png" ><p>CBdragon</p></div>
			<div class="col-md-6"><img class="img-fluid" src="img/t21CBlucy.png" ><p>CBlucy</p></div>
			<div class="col-md-6"><img class="img-fluid" src="img/t21wall-e.png" ><p>wall-e</p></div>
		</div>
	    <br>
	    2.3 We test our BVH acceleration on two rendering cases, one is CBcoil and another one is CBbunny. About CBcoil, without BVH acceleration, it took 22.8770 sec to do the rendering, while it took
		0.0846 with BVH acceleration. About CBcoil, without BVH acceleration, it took 134.9340 sec to do the rendering, while it took 0.0735 with BVH acceleration. It is very interesting to see that though some case takes
	    much longer to render without BVH acceleration, with BVH acceleration they almost finish rendering in the same time. One reason we think is though the number of primitives in two rendering cases might
		be significantly different, if the distributions of these primitives in the environments are quite similar, the rendering time would be similar, but of course we also need to take the size and the viewpoint and some other factors
		into consideration.
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t22CBcoil.png" ><p>CBcoil</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t22CBbunny.png" ><p>CBbunny</p></div>

	</div>
	</p>

</div>

<div class="container">
	<h2 id="task3">Part 3</h2>
	<p>
		3.1 To implement area-weighted vertex normals, after obtaining some halfedge rooted at the given vertex, we used twin() and next() to traverse all faces incident to that vertex and saved one halfedge of each face into
		a new vector. Then, we traversed all halfedge in that vector to get the normal of the corresponding face. About obtaining the normal of the face, we could call next() twice then we would get three consecutive
		halfedge in that face. Then we could access the three vertexes in that face and their position. Given these three vertexes, we could then simply obtain the normal and the area of that face. One thing worth mentioning is that
		we would do normalization on this normal vector. The last thing we did was weighing all these normals of faces by their corresponding areas and took the result as the final area-weighted vertex normal.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t3_1.jpg" ><p>w/o vertex normals</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t3_2.jpg" ><p>with vertex normals</p></div>
	</div>
</div>

<div class="container">
	<h2 id="task4">Part 4</h2>
	<p>
		4.1 We followed some suggestions mentioned in the instruction and the provided <a href="http://15462.courses.cs.cmu.edu/fall2015content/misc/HalfedgeEdgeOpImplementationGuide.pdf">guide</a>. Since we wouldn't add or delete any new elements.
		We first drew a diagram showing the elements before edge flip and that after edge flip. Then we collected all elements no matter whether they would be changed. According to the change found in
		the diagram, we then updated the pointers for all elements no matter whether they would be affected by the edge flip. Finally, we removed some unnecessary operations. Following this guide, we succeeded
		implementing edge flip in one go.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t4_1.jpg" ></div>
	</div>
</div>

<div class="container">
	<h2 id="task5">Part 5</h2>
	<p>
		5.1 For edge split, I first drew out the edge / halfedge / vertex distribution dialog similar to the one provided in the primer link.
		As shown image below, the v4 represents the new vertex being added, and I reused the original h0 as the halfedge going out from v4. Then in the implementation, I simply iterate all the halfedges from h0 to h15, and then map its next / twin / vertext/ edge and face respectively according to the diagram.
		Even though this might lead to redundancy and sometimes the half edge mapping didn't change, this method allows me to make sure every half edge and relationship is updated thoroughly.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t5_1.jpg" ><p>Edge split diagram: after split</p></div>
	</div>
	<p>
		5.2 The images below are screenshots of teapot.dae, before and after some edge splits.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t5_2_1.png" ><p>Teapot.dae: before edge split</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t5_2_2.png" ><p>Teapot.dae: after edge split</p></div>
	</div>
	<p>
		5.3 The images below are screenshots of teapot.dae, before and after some edge splits and edge flips.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t5_3_1.png" ><p>Teapot.dae: before edge split or edge flip</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t5_3_2.png" ><p>Teapot.dae: after combination of edge split and edge flips</p></div>
	</div>
	<p>
		5.4 I met one minor bug when I was implementing task 6. As the image below shown, there are some holes in the cube.dae when performing loop subdivision. Then I found many people encounter similar issues in ed discussion and apparently this was related to split edge function. Following their advice, I rechecked my split function, and
		iterated through all the edges/halfedges/vertices/faces in splitEdge() function, which finally fixed the issue. It was indeed really hard to debug this portion.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t5_4.png" ><p>Cube.dae, some shapes with bugs inside edge split</p></div>
	</div>
</div>

<div class="container">
	<h2 id="task6">Contributions</h2>
	<p>
		<b>6.1 Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</b>
		<br>
		6.1.1 I implemented the loop subdivision as suggested in the description. First, I iterated through all vertices in the mesh, and for each vertex,
		I used halfedge and twin edge's traverse to iterating over halfedges around each vertex to calculate their neighborsum, then I assigned u * originalNeighborSum + (1 - count * u) * v->position to be the new position of each vertex. Second, I iterated through all edges, and found the a, b,c,d points
		of the given edge to calculate what should be the new position of the split vertex. Third, I itereated through all the existing edges, and split the edge. For the new vertex from the split edge, I marked it as new edge, and assigned its new position from the edge's newPosition, and marked the new edges (that are not along the original edge)
		to be new edge. Forth, I iterated the edges again to flip all the new edges that connects an old and new vertex. Finally, I marked all vertices and edges as not new, and assigned vertex's position = newPosition.
		<br>
		For the debugging tricks, I printed out the position of the vertices as a ID identification for each vertex, and always print out to check the "new" attribute of the edges / vertex. Initially one of the bug is that I was stuck in a infinite loop while traversing through edges in step 3. I printed out the vertex of the halfedge related to the current edge, and printed out if the
		edge is new or not, and then realized that my bug was caused by traversing through all edges instead of only the original mesh.
	</p>
	<p>
		6.2.1 As we could see from the cow.dae, originally the cow's face and the corner of the horns was pretty sharp without loop subdivision. After 1-2 loop subdivision, we could see that the horns became round and smooth without its original sharpness. This is because we have performed many edge flip and split on the corners,
		so the sharp corners are represented by more triangles after loop subdivision. Also we have recalculated the positions of the new vertex as the weighted sum of the neighborhood vertices, which smoothed out the sharpness.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_1.png" ><p>Without loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_2.png" ><p>1 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_3.png" ><p>2 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_4.png" ><p>Zoom in on the horns after 2 loop subdivision</p></div>
	</div>
	<p> 6.2.2 To reduce the smoothness effect, we could pre-splitting some of the edges, so that the corner sharpness can be represented by more edges in the original mesh. Then in the loop subdivision, since each vertex will be calculated by its neighborhood vertex, this pre-splitting will create more neighbor vertices around the corner,
		thus weighted sum could still maintain its sharpness. In the images below, the left cow horn has some pre-splitting edges first before loop subdivision, while the right cow horn on the right image doesn't have any pre-splitting. We could see that it is clear that the left corn is more sharp than the right horn.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_5.png" ><p>Loop subdivision after splitting more edges on the corner edge first</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_2_6.png" ><p>Loop subdivision without pre-processing</p></div>
	</div>
	<p>
		6.3 As we could see that after iterations of loop subdivision on the cube, it became slightly asymmetric. This is because the original cube only had 1 edge on each of the face. From the 3/8 * (A + B) + 1/8 * (C + D) formula, when performing edge split, we calculated the new vertex's position
		and assigned different weights to the neighbor vertices, which will cause unbalance and formed the asymmetric shape.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_1.png" ><p>Without loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2.png" ><p>1 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_3.png" ><p>2 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_4.png" ><p>4 loop subdivision</p></div>
	</div>
	<p>
		To solve this assymetric issue, we just need to perform an edge split on each face first before loop subdivision so that each face has 2 edges. Then neighborhood vertex will have an equal weight / contribution to the new vertex in loop subdivision, and will form a more symmetrics shape after subdivision.
		As we could see from the images below, the cubes that are edge split first will be much more balanced / symmetric than the original form.
	</p>
	<div class="row justify-content-md-center text-center">
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2_1.png" ><p>Edge split first for each face</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2_2.png" ><p>After 1 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2_3.png" ><p>After 2 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2_4.png" ><p>After 3 loop subdivision</p></div>
		<div class="col-md-6"><img class="img-fluid" src="img/t6_3_2_5.png" ><p>After n loop subdivision</p></div>
	</div>
</div>

</body>
</html>